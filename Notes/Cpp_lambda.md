# [람다 함수] 알아야 할 것 정리

C++11부터 도입된 언어 기능으로, 익명 함수 객체를 생성한다. 캡처를 통해 외부 변수를 사용할 수 있어 클로저를 구현한다.

## 기본 개념
- **익명성**: 이름 없는 함수 객체로, 선언과 동시에 사용 가능.
- **캡처**: 외부 변수를 값([=]) 또는 참조([&])로 캡처하여 내부에서 접근. [=]는 람다 본문에서 실제로 사용되는 지역 변수만 값으로 캡처하며, 스코프 체인을 따라 올라가며 접근 가능한 변수를 포함.
- **클로저 타입**: 람다 표현식이 컴파일러에 의해 생성되는 익명 클래스 타입. 이 타입의 객체는 함수 호출 연산자를 오버로딩하며, 캡처된 변수를 멤버로 저장. auto로 선언 시 컴파일러가 타입을 추론.
- **가변성**: mutable 키워드로 값 캡처 변수를 수정 가능.
- **용도**: 콜백, 알고리즘, 이벤트 핸들러 등에서 간단한 함수 정의에 유용.

## 생성자 (또는 시그니처)
```cpp
// 기본 람다: 매개변수 없음, 반환 타입 자동 추론
auto lambda = []() { return 42; };

// 매개변수와 반환 타입 지정
auto lambda = [](int x) -> int { return x * 2; };

// 캡처: 값으로 모든 외부 변수 캡처
auto lambda = [=](int x) { return x + a; };

// 참조로 캡처
auto lambda = [&](int x) { return x + a; };

// 개별 캡처: a는 값, b는 참조
auto lambda = [a, &b](int x) { return x + a + b; };

// mutable: 값 캡처 변수를 수정 가능
auto lambda = [=]() mutable { a++; return a; };
```

## 주요 멤버 함수 (또는 오버로딩)
- 람다는 함수 객체이므로 직접 호출: `lambda(args)`.
- 함수 포인터로 변환: 캡처 없는 경우에만 가능, `bool(*fp)(int) = [](int x){ return x > 0; };`.

## 연산자
- `()`: 호출 연산자, 람다를 함수처럼 호출.
- `==`, `!=`: 직접 비교 불가, std::function으로 래핑 후 비교 가능하지만 권장되지 않음.

## 기타 (이터레이터, 헬퍼 함수 등)
- **제네릭 람다**: C++14부터 auto 매개변수 지원, `[](auto x){ return x; };`.
- **중첩 스코프 캡처**: 람다는 자신의 스코프와 외부 스코프의 변수를 모두 캡처 가능. 겹치는 변수명 시 가장 가까운 스코프 우선. 외부 변수를 명시적으로 캡처하려면 람다 정의 전에 복사하거나, 람다를 외부 스코프에서 정의.
- **글로벌 변수**: 캡처 불필요, 람다 본문에서 직접 접근 가능 (::a로 명시적 참조 가능).
- **타입 추론**: auto로 클로저 타입을 추론하는 것이 표준적.
- **캡처 리스트([]) vs 매개변수 리스트(())**: `[]`는 외부 스코프 변수를 캡처하여 람다 내부에서 사용 (정의 시점). `()`는 람다 호출 시 전달되는 인자 정의 (호출 시점). 둘 다 필수적이나 역할 다름.

## 사용 예시
```cpp
int main() {
    int a = 10;
    // 값 캡처 람다
    auto lambda = [=](int x) { return x + a; };
    std::cout << lambda(5) << std::endl;  // 15

    // 참조 캡처로 외부 수정
    int sum = 0;
    auto adder = [&](int x) { sum += x; };
    adder(3); adder(7);
    std::cout << sum << std::endl;  // 10
}
```